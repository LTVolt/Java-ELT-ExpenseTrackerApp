# Java-ELT-ExpenseTrackerApp

Major project using Java, this time combining the backend with a frontend for a full-stack approach.

Documents on how to use both the backend and the frontend will be on each respective folders, while this one will serve as documentation.

**Backend Documentation:**

This project utilizes authentication in order to create and manage a stable userbase, and each user has access to their own dashboard with their own expenses.
As such, 2 Entites were created: User, and Expense. A User is nothing more than a JPA entity mapped to the users table in the database. It is used in Auth, links to expenses by using the @OneToMany annotation, and in security layers though roles. Therefore, a User entity has:

1. An id - the unique identifier, user does not control this number, as it is the auto incremented primary key for the database;
2. A username - the unique login credential indentifying the user to themselves;
3. A password - An SHA encrypted password using base64 decryption along with a 256+ byte admin defined seed;
4. A role - An authorization level used to let each user access different parts of the backend / frontend;
5. A token - It's a JWT generated using the HS256 algorithm upon login. This token allows for Authorization when using backend methods. Resets upon logout, or expires after 10 hours.

Similarly, an Expense, which is the main businees entity representing each individual expense for each user, has:

1. An id - the unique identifier, it is the auto incremented primary key for the database;
2. A description - Short explanation for what the expense is for;
3. An amount - number representing how much the expense was for;
4. A date - timestamp signaling when the expense was processed;
5. A category - An enum separating expenses by category;
6. A user - This is the database's foreign key that allows identification of each expense.

Needing several Users and Expenses, it is natural to create Repositories for each Entity. These are Spring Data JPA repos that handle CRUD operations and abstract SQL operations.

They both manage access to each table in the DB, the Users one making use of both the AuthService and ExpenseService detailed further down, and Expense one only the latter. The methods used in these repos are custom methods generated by Spring using naming convention. The @Query annotation allows for the aforementioned SQL abstration. By extending the JpaRepository we get access to useful methods much as save(), deleteById(), findById(), etc.

The actual logic of the operations happens in the Services files. They coordinate between Controllers (explained further down) and Repositories, enforce rules, handle authentication, expense ownership and monthly summaries, token generation and validation.

AuthService core methods:
1. register(AuthRequest request) - Constructs a user based on what they wanted (the request), encodes the password and assigns the proper role (all users start with the USER role). This also returns a JWT immediately for an automatic login if desired;
2. login(AuthRequest request) - Validates the passed username, compares the password using BCrypt and returns a freah JWT to be used in the started session.

ExpenseService core methods:
1. addExpense(ExpenseRequestDTO dto, String username) - Finds the authed user by their username, maps the DTO to an Expense Entity, saves it to the DB, and finally returns the mapped response DTO;
2. getUserExpenses(String username) - Finds all expenses owned by the passed user, preventing cross-user access;
3. updateExpense(Long id, ExpenseRequestDTO dto, String username) - Finds the passed expense by its ID, checks if it is owned by the passed username, updates the expense only if the aforementioned conditions pass;
4. deleteExpense(Long id, String username) - Obvious what is does, ensuring ownership before deletion;
5. getCategorySummary(String username, int month, int year) - Calls the custom Query in the Expense repo, returning a Map of Category and BigDecimal with the sum of each category.

It seems only appropriate to now focus on explaining the Controllers. They are naturally the face of the backend through RESTful APIs. As with the Services, we have a Controller for the Auth, and another for Expense. Each of them maps to a base URL, and uses the @RestController annotation to send JSON responses. These call the Services, therefore never talking to the DB or even the repos directly.

As for the AuthController:
1. It handles authentication through the POST method at the /api/auth/register and /api/auth/login endpoints, returning JWTs if successful;
2. The @RestController annotation marks this as a REST API, having an automatic @ResponseBody;
3. @PostMapping allows for using the POST methods;
4. The @RequestBody is quite important is at parses incoming JSON to a Java object;
5. The register(@RequestBody AuthRequest request) method delegates to AuthService's register method explained earlier, accepts a username and password in the request's body and returns a JWT.
6. Similarly, the login(@RequestBody AuthRequest request) delegates to AuthService's login method.
7. Note: Both register and login are the ONLY endpoints that do not require a JWT to work, as they are the ones that provide it.

As for the ExpenseController:
1. It handles CRUD operations related to expenses;
2. Has the api/expenses endpoint;
3. All routes now require authentication, having to include the Bearer token in the header;
4. Like the AuthController, it bears the @RestController, @RequestMapping("endpoint"), @XXXMapping(GET / POST / necessary) for the HTTP methods and also has @PathVariable and @RequestParam for dynamic routes and filters;
5. The addExpense(@RequestBody ExpenseRequestDTO dto, Authentication authentication) method first authenticates the user via authorization.getName(), using DTOs to validate the incoming data and then calls the ExpenseService.addExpense() to actually perform the method to add it;
6. The getExpenses(Authentication authentication) method fetches all expenses for the current user;
7. The updateExpense(@PathVariable Long id, @RequestBody ExpenseRequestDTO dto, Authentication authentication) method updates the passed expense only if owner by the authenticated user;
8. Same with the deleteExpense() method;
9. The filterByDateRange(@RequestParam("start") String start, @RequestParam("end") String end, Authentication authentication) method converts the passed strings to LocalDates with the DD-MM-YYYY format, and passes it to the Service for date filtering;
10. The getSummary(@RequestParam("month") int month, @RequestParam("year") int year, Authentication authentication) method retuns the totals by Category.

This way, the logic is kept out of the Controllers, DTOs are used for the appropriate I/O, they protect the endpoints by using Authentication context and they use REST conventions through clean paths, all while avoiding overexposing data (each user only sees their own expenses).

Moving on to Security - the frontend walls. Here user authentication, token validation, endpoint securing and JWT wiring into Spring Security are handled.

Starting with JwtService - this Service manages all JWT logic, from creating them to parsing them and validating their expiration and signature. Its core methods are:
1. generateToken(String username) - This method creates a JWT with the subject equaling the username provided;
2. extractUsername(String token) - This one parses the provided token and retuns the user it belongs to;
3. isTokenValid(token, username) - This one checks if both provided parameters match, along with the expiry;
4. getSignInKey() - Finally, this method generated the secret signing key from a Base64 String.
5. As stated in the beginning of this document, we use HS256 - an HMAC-based signature algorithm to generate the tokens;
6. The SECRET_KEY variable is the app's private signing key - MUST be 256+ bit, or else it doesn't work for HS256.

Next up - the JwtAuthenticationFilter - this is a custom Spring Security filter that runs before every secured request, checks if the provided Authorization header has a valid JWT, and if yes, sets up the security context. So, in order it:
1. Extracts the Authorization header;
2. Pulls out the token;
3. Validates it through JwtService;
4. Gets the user through the DB;
5. Sets the Spring Security context if everything checks out.
Without this, Spring won't know who is asking what they are asking.

For this to run properly (and trust me, this next one gave me some headaches), we have our own SecurityConfig, where we configure the main Spring Security class. This handles which routes are public (grr CORS), disables session states, plugs in the custom JWT filter and sets up the password encoding.

Let's have a look:
```
http
  .csrf(csrf -> csrf.disable())                     // No CSRF needed for APIs
  .authorizeHttpRequests(auth -> auth
      .requestMatchers("/**").permitAll()           // Allows all endpoints
      .anyRequest().authenticated()                 // Everything else requires JWT
  )
  .sessionManagement(sess -> sess
      .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
  )
  .addFilterBefore(jwtFilter, UsernamePasswordAuthenticationFilter.class);
```
This creates a fully stateless security system with no cookies, no sessions and every request must include a token. Now pay attention to line 4: having ("/**") allows all endpoints to request data. If you change this, any endpoint that doesn't fall in with what you passed WILL NOT allow ANY methods to be called, and will be blocked by CORS, EVEN IF THE METHODS HAVE THE @CrossOrigin ANNOTATION. Note that even with this, this annotation is STILL required.

Congratulations, you've made it to the final section: the DTOs.

DTOs are used are in order to send clean and controlled data between the client and the server, they also prevent overexposing internal data like Users and Expenses, and, last but not least, they make validation and serialization safer and clearer.

There are 4 types of DTOs in this project: AuthRequest, AuthResponse, ExpenseRequest and ExpenseResponse.
