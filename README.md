# Java-ELT-ExpenseTrackerApp

Major project using Java, this time combining the backend with a frontend for a full-stack approach.

Documents on how to use both the backend and the frontend will be on each respective folders, while this one will serve as documentation.

**Backend Documentation:**

This project utilizes authentication in order to create and manage a stable userbase, and each user has access to their own dashboard with their own expenses.
As such, 2 Entites were created: User, and Expense. A User is nothing more than a JPA entity mapped to the users table in the database. It is used in Auth, links to expenses by using the @OneToMany annotation, and in security layers though roles. Therefore, a User entity has:

1. An id - the unique identifier, user does not control this number, as it is the auto incremented primary key for the database;
2. A username - the unique login credential indentifying the user to themselves;
3. A password - An SHA encrypted password using base64 decryption along with a 256+ byte admin defined seed;
4. A role - An authorization level used to let each user access different parts of the backend / frontend;
5. A token - It's a JWT generated using the HS256 algorithm upon login. This token allows for Authorization when using backend methods. Resets upon logout, or expires after 10 hours.

Similarly, an Expense, which is the main businees entity representing each individual expense for each user, has:

1. An id - the unique identifier, it is the auto incremented primary key for the database;
2. A description - Short explanation for what the expense is for;
3. An amount - number representing how much the expense was for;
4. A date - timestamp signaling when the expense was processed;
5. A category - An enum separating expenses by category;
6. A user - This is the database's foreign key that allows identification of each expense.

Needing several Users and Expenses, it is natural to create Repositories for each Entity. These are Spring Data JPA repos that handle CRUD operations and abstract SQL operations.

They both manage access to each table in the DB, the Users one making use of both the AuthService and ExpenseService detailed further down, and Expense one only the latter. The methods used in these repos are custom methods generated by Spring using naming convention. The @Query annotation allows for the aforementioned SQL abstration. By extending the JpaRepository we get access to useful methods much as save(), deleteById(), findById(), etc.

The actual logic of the operations happens in the Services files. They coordinate between Controllers (explained further down) and Repositories, enforce rules, handle authentication, expense ownership and monthly summaries, token generation and validation.

AuthService core methods:
1. register(AuthRequest request) - Constructs a user based on what they wanted (the request), encodes the password and assigns the proper role (all users start with the USER role). This also returns a JWT immediately for an automatic login if desired;
2. login(AuthRequest request) - Validates the passed username, compares the password using BCrypt and returns a freah JWT to be used in the started session.

ExpenseService core methods:
1. addExpense(ExpenseRequestDTO dto, String username) - Finds the authed user by their username, maps the DTO to an Expense Entity, saves it to the DB, and finally returns the mapped response DTO;
2. getUserExpenses(String username) - Finds all expenses owned by the passed user, preventing cross-user access;
3. updateExpense(Long id, ExpenseRequestDTO dto, String username) - Finds the passed expense by its ID, checks if it is owned by the passed username, updates the expense only if the aforementioned conditions pass;
4. deleteExpense(Long id, String username) - Obvious what is does, ensuring ownership before deletion;
5. getCategorySummary(String username, int month, int year) - Calls the custom Query in the Expense repo, returning a Map of Category and BigDecimal with the sum of each category.

It seems only appropriate to now focus on explaining the Controllers. They are naturally the face of the backend through RESTful APIs. As with the Services, we have a Controller for the Auth, and another for Expense. Each of them maps to a base URL, and uses the @RestController annotation to send JSON responses. These call the Services, therefore never talking to the DB or even the repos directly.

As for the AuthController:
1. It handles authentication through the POST method at the /api/auth/register and /api/auth/login endpoints, returning JWTs if successful;
2. The @RestController annotation marks this as a REST API, having an automatic @ResponseBody;
3. @PostMapping allows for using the POST methods;
4. The @RequestBody is quite important is at parses incoming JSON to a Java object;
5. The register(@RequestBody AuthRequest request) method delegates to AuthService's register method explained earlier, accepts a username and password in the request's body and returns a JWT.
6. Similarly, the login(@RequestBody AuthRequest request) delegates to AuthService's login method.
7. Note: Both register and login are the ONLY endpoints that do not require a JWT to work, as they are the ones that provide it.

As for the ExpenseController:
1. It handles CRUD operations related to expenses;
2. Has the api/expenses endpoint;
3. All routes now require authentication, having to include the Bearer token in the header;
4. Like the AuthController, it bears the @RestController, @RequestMapping("endpoint"), @XXXMapping(GET / POST / necessary) for the HTTP methods and also has @PathVariable and @RequestParam for dynamic routes and filters;
5. The addExpense(@RequestBody ExpenseRequestDTO dto, Authentication authentication) method first authenticates the user via authorization.getName(), using DTOs to validate the incoming data and then calls the ExpenseService.addExpense() to actually perform the method to add it;
6. The getExpenses(Authentication authentication) method fetches all expenses for the current user;
7. The updateExpense(@PathVariable Long id, @RequestBody ExpenseRequestDTO dto, Authentication authentication) method updates the passed expense only if owner by the authenticated user;
8. Same with the deleteExpense() method;
9. The filterByDateRange(@RequestParam("start") String start, @RequestParam("end") String end, Authentication authentication) method converts the passed strings to LocalDates with the DD-MM-YYYY format, and passes it to the Service for date filtering;
10. The getSummary(@RequestParam("month") int month, @RequestParam("year") int year, Authentication authentication) method retuns the totals by Category.

